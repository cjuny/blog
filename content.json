{"pages":[],"posts":[{"title":"Hooks运行原理","text":"useState的实现原理调用useState会返回一个数组：一个state和一个更新state的函数。在初始化渲染时，返回的state的初始值为调用useState传入的第一个参数，后续渲染时会被忽略。了解了useState的基本使用，来看一个使用例子。如下面代码所示，当点击按钮时，将调用setCount,count被更新，触发视图更新。 1234567891011121314import React, { useState } from 'react';function Example() { const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 基于useState的基础用法，模拟实现一个简单的useState。 12345678910let state;function useState(initialValue) { state = state || initialValue; function setState(newState) { state = newState; render(); } return [state, setState];} useEffect的实现原理12345678910111213let _deps; // _deps 记录 useEffect 上一次的 依赖function useEffect(callback, depArray) { const hasNoDeps = !depArray; // 如果 dependencies 不存在 const hasChangedDeps = _deps ? !depArray.every((el, i) =&gt; el === _deps[i]) // 两次的 dependencies 是否完全相等 : true; /* 如果 dependencies 不存在，或者 dependencies 有变化*/ if (hasNoDeps || hasChangedDeps) { callback(); _deps = depArray; }} not magic, just arrays我们简易实现了useState和useEffect，但是两个hooks的状态都是保存在一个全局变量中，使得hooks只能被使用一次。如《React hooks: not magic, just arrays》所写，我们可以使用数组，来解决 Hooks 的复用问题。 首次渲染的时候，根据hooks的调用顺序，把state，deps等按顺序保存到全局数组中，每次声明使用cursor记录位置并加一 更新的时候，cursor重置为0。根据hooks的声明顺序，取出记录的值 12345678910111213141516171819202122232425let memoizedState = []; // hooks 存放在这个数组let cursor = 0; // 当前 memoizedState 下标function useState(initialValue) { memoizedState[cursor] = memoizedState[cursor] || initialValue; const currentCursor = cursor; function setState(newState) { memoizedState[currentCursor] = newState; render(); } return [memoizedState[cursor++], setState]; // 返回当前 state，并把 cursor 加 1}function useEffect(callback, depArray) { const hasNoDeps = !depArray; const deps = memoizedState[cursor]; const hasChangedDeps = deps ? !depArray.every((el, i) =&gt; el === deps[i]) : true; if (hasNoDeps || hasChangedDeps) { callback(); memoizedState[cursor] = depArray; } cursor++;} 过程参考下图： hooks的使用规则在react的官方文档中有两条hooks使用规则： 1.只在最顶层使用 Hook如前文所说，钩子的状态都按声明的顺序保存，由于每次数据变更时都会重新渲染React组件，所以必须保证每次渲染都按照相同的顺序调用完全相同的钩子。 例如你在if里面使用了hook： 1234if(bool){ const [count, setCount] = useState(0);}const [name, setName] = useState('Bob'); 该count状态有时会被创建，有时候不会。这会导致React无法在内部进行跟踪，会使该组件存储的所有状态的值混乱。 2.只在 React 函数中调用 Hook该规则存在的原因跟规则1类似。 例如，如果我们创建了一个名为doSomething的函数： 1234function doSomething() { const [count, setCount] = useState(0) ...} 然后，你或其他开发人员可能没有意识到doSomething函数调用了hook，并可能会尝试doSomething无序调用： 123const Counter = () =&gt; { return &lt;button onClick={doSomething}&gt;Do it!&lt;/button&gt;} 因为React在内部无法跟踪乱序的hook（与规则1相同），因此只能在react组件最顶层或自定义hook中使用hook。 参考链接 Use React Hooks Correctly with These Two Rules React Hooks 原理 React hooks: not magic, just arrays","link":"/2021/03/31/Hooks%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"hooks","slug":"hooks","link":"/tags/hooks/"}],"categories":[{"name":"react","slug":"react","link":"/categories/react/"}]}