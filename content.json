{"pages":[],"posts":[{"title":"OAuth 2.0学习总结","text":"一、OAuth 2.0 是什么？OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。比如，使用微信登录第三方应用，需要使用到用户的微信数据。为了获取这些信息，就必须经过微信的授权系统。OAuth是一种开放协议, 允许用户让第三方应用以安全且标准的方式获取该用户在某一网站，移动或者桌面应用上存储的秘密的资源（如用户个人信息，照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 一、OAuth 2.0 的四种授权方式OAuth2.0有4种授权模式： 授权码模式（authorization code）简化模式（implicit）密码模式（resource owner password credentials）客户端模式（client credentials） 1.授权码（authorization-code）授权码方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。 这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。 1.用户访问客户端，客户端将用户导向认证服务器（使用预先申请获得的client_id，让认证服务器知道是谁在请求）。2.用户选择是否给予客户端授权。3.假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。4.客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的 后台服务器 上完成的，对用户不可见。5.认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。 2.隐藏式（implicit）有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。 1.用户访问客户端，客户端将用户导向认证服务器。2.用户选择是否给予客户端授权。3.假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时令牌作为 URL 锚点参数。客户端直接在前端拿到令牌 注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。 3.密码式（password）如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。 1.客户端要求用户提供访问资源服务器的用户账号和密码。2.客户端使用账号和密码直接向认证服务器申请令牌 这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。 4.客户端凭证（client credentials）最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。 1.客户端直接在命令行向认证服务器请求令牌 这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。 令牌的使用A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。 此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。 1curl -H &quot;Authorization: Bearer ACCESS_TOKEN&quot; &quot;https://api.b.com&quot; 上面命令中，ACCESS_TOKEN就是拿到的令牌。 更新令牌令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。 具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。 B 网站验证通过以后，就会颁发新的令牌。 令牌与密码的区别1.令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。 2.令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。 3.令牌有权限范围，对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。","link":"/2021/04/28/OAuth%202.0/"},{"title":"Hooks运行原理","text":"useState的实现原理调用useState会返回一个数组：一个state和一个更新state的函数。在初始化渲染时，返回的state的初始值为调用useState传入的第一个参数，后续渲染时会被忽略。了解了useState的基本使用，来看一个使用例子。如下面代码所示，当点击按钮时，将调用setCount,count被更新，触发视图更新。 1234567891011121314import React, { useState } from 'react';function Example() { const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 基于useState的基础用法，模拟实现一个简单的useState。 12345678910let state;function useState(initialValue) { state = state || initialValue; function setState(newState) { state = newState; render(); } return [state, setState];} useEffect的实现原理12345678910111213let _deps; // _deps 记录 useEffect 上一次的 依赖function useEffect(callback, depArray) { const hasNoDeps = !depArray; // 如果 dependencies 不存在 const hasChangedDeps = _deps ? !depArray.every((el, i) =&gt; el === _deps[i]) // 两次的 dependencies 是否完全相等 : true; /* 如果 dependencies 不存在，或者 dependencies 有变化*/ if (hasNoDeps || hasChangedDeps) { callback(); _deps = depArray; }} not magic, just arrays我们简易实现了useState和useEffect，但是两个hooks的状态都是保存在一个全局变量中，使得hooks只能被使用一次。如《React hooks: not magic, just arrays》所写，我们可以使用数组，来解决 Hooks 的复用问题。 首次渲染的时候，根据hooks的调用顺序，把state，deps等按顺序保存到全局数组中，每次声明使用cursor记录位置并加一 更新的时候，cursor重置为0。根据hooks的声明顺序，取出记录的值 12345678910111213141516171819202122232425let memoizedState = []; // hooks 存放在这个数组let cursor = 0; // 当前 memoizedState 下标function useState(initialValue) { memoizedState[cursor] = memoizedState[cursor] || initialValue; const currentCursor = cursor; function setState(newState) { memoizedState[currentCursor] = newState; render(); } return [memoizedState[cursor++], setState]; // 返回当前 state，并把 cursor 加 1}function useEffect(callback, depArray) { const hasNoDeps = !depArray; const deps = memoizedState[cursor]; const hasChangedDeps = deps ? !depArray.every((el, i) =&gt; el === deps[i]) : true; if (hasNoDeps || hasChangedDeps) { callback(); memoizedState[cursor] = depArray; } cursor++;} 过程参考下图： hooks的使用规则在react的官方文档中有两条hooks使用规则： 1.只在最顶层使用 Hook如前文所说，钩子的状态都按声明的顺序保存，由于每次数据变更时都会重新渲染React组件，所以必须保证每次渲染都按照相同的顺序调用完全相同的钩子。 例如你在if里面使用了hook： 1234if(bool){ const [count, setCount] = useState(0);}const [name, setName] = useState('Bob'); 该count状态有时会被创建，有时候不会。这会导致React无法在内部进行跟踪，会使该组件存储的所有状态的值混乱。 2.只在 React 函数中调用 Hook该规则存在的原因跟规则1类似。 例如，如果我们创建了一个名为doSomething的函数： 1234function doSomething() { const [count, setCount] = useState(0) ...} 然后，你或其他开发人员可能没有意识到doSomething函数调用了hook，并可能会尝试doSomething无序调用： 123const Counter = () =&gt; { return &lt;button onClick={doSomething}&gt;Do it!&lt;/button&gt;} 因为React在内部无法跟踪乱序的hook（与规则1相同），因此只能在react组件最顶层或自定义hook中使用hook。 参考链接 Use React Hooks Correctly with These Two Rules React Hooks 原理 React hooks: not magic, just arrays","link":"/2021/03/31/Hooks%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"hooks","slug":"hooks","link":"/tags/hooks/"},{"name":"OAuth","slug":"OAuth","link":"/tags/OAuth/"}],"categories":[{"name":"react","slug":"react","link":"/categories/react/"},{"name":"OAuth","slug":"OAuth","link":"/categories/OAuth/"}]}