{"pages":[],"posts":[{"title":"Hooks运行原理","text":"useState的实现原理调用useState会返回一个数组：一个state和一个更新state的函数。在初始化渲染时，返回的state的初始值为调用useState传入的第一个参数，后续渲染时会被忽略。了解了useState的基本使用，来看一个使用例子。如下面代码所示，当点击按钮时，将调用setCount,count被更新，触发视图更新。 1234567891011121314import React, { useState } from 'react';function Example() { const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 基于useState的基础用法，模拟实现一个简单的useState。 12345678910let state;function useState(initialValue) { state = state || initialValue; function setState(newState) { state = newState; render(); } return [state, setState];} useEffect的实现原理12345678910111213let _deps; // _deps 记录 useEffect 上一次的 依赖function useEffect(callback, depArray) { const hasNoDeps = !depArray; // 如果 dependencies 不存在 const hasChangedDeps = _deps ? !depArray.every((el, i) =&gt; el === _deps[i]) // 两次的 dependencies 是否完全相等 : true; /* 如果 dependencies 不存在，或者 dependencies 有变化*/ if (hasNoDeps || hasChangedDeps) { callback(); _deps = depArray; }} not magic, just arrays我们简易实现了useState和useEffect，但是两个hooks的状态都是保存在一个全局变量中，使得hooks只能被使用一次。如《React hooks: not magic, just arrays》所写，我们可以使用数组，来解决 Hooks 的复用问题。 首次渲染的时候，根据hooks的调用顺序，把state，deps等按顺序保存到全局数组中，每次声明使用cursor记录位置并加一 更新的时候，cursor重置为0。根据hooks的声明顺序，取出记录的值 12345678910111213141516171819202122232425let memoizedState = []; // hooks 存放在这个数组let cursor = 0; // 当前 memoizedState 下标function useState(initialValue) { memoizedState[cursor] = memoizedState[cursor] || initialValue; const currentCursor = cursor; function setState(newState) { memoizedState[currentCursor] = newState; render(); } return [memoizedState[cursor++], setState]; // 返回当前 state，并把 cursor 加 1}function useEffect(callback, depArray) { const hasNoDeps = !depArray; const deps = memoizedState[cursor]; const hasChangedDeps = deps ? !depArray.every((el, i) =&gt; el === deps[i]) : true; if (hasNoDeps || hasChangedDeps) { callback(); memoizedState[cursor] = depArray; } cursor++;} 过程参考下图： hooks的使用规则在react的官方文档中有两条hooks使用规则： 1.只在最顶层使用 Hook如前文所说，钩子的状态都按声明的顺序保存，由于每次数据变更时都会重新渲染React组件，所以必须保证每次渲染都按照相同的顺序调用完全相同的钩子。 例如你在if里面使用了hook： 1234if(bool){ const [count, setCount] = useState(0);}const [name, setName] = useState('Bob'); 该count状态有时会被创建，有时候不会。这会导致React无法在内部进行跟踪，会使该组件存储的所有状态的值混乱。 2.只在 React 函数中调用 Hook该规则存在的原因跟规则1类似。 例如，如果我们创建了一个名为doSomething的函数： 1234function doSomething() { const [count, setCount] = useState(0) ...} 然后，你或其他开发人员可能没有意识到doSomething函数调用了hook，并可能会尝试doSomething无序调用： 123const Counter = () =&gt; { return &lt;button onClick={doSomething}&gt;Do it!&lt;/button&gt;} 因为React在内部无法跟踪乱序的hook（与规则1相同），因此只能在react组件最顶层或自定义hook中使用hook。 参考链接 Use React Hooks Correctly with These Two Rules React Hooks 原理 React hooks: not magic, just arrays","link":"/2021/03/31/Hooks%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"},{"title":"OAuth 2.0学习总结","text":"一、OAuth 2.0 是什么？OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。比如，使用微信登录第三方应用，需要使用到用户的微信数据。为了获取这些信息，就必须经过微信的授权系统。OAuth是一种开放协议, 允许用户让第三方应用以安全且标准的方式获取该用户在某一网站，移动或者桌面应用上存储的秘密的资源（如用户个人信息，照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 一、OAuth 2.0 的四种授权方式OAuth2.0有4种授权模式： 授权码模式（authorization code）简化模式（implicit）密码模式（resource owner password credentials）客户端模式（client credentials） 1.授权码（authorization-code）授权码方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。 这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。 1.用户访问客户端，客户端将用户导向认证服务器（使用预先申请获得的client_id，让认证服务器知道是谁在请求）。2.用户选择是否给予客户端授权。3.假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。4.客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的 后台服务器 上完成的，对用户不可见。5.认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。 2.隐藏式（implicit）有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。 1.用户访问客户端，客户端将用户导向认证服务器。2.用户选择是否给予客户端授权。3.假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时令牌作为 URL 锚点参数。客户端直接在前端拿到令牌 注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。 3.密码式（password）如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。 1.客户端要求用户提供访问资源服务器的用户账号和密码。2.客户端使用账号和密码直接向认证服务器申请令牌 这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。 4.客户端凭证（client credentials）最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。 1.客户端直接在命令行向认证服务器请求令牌 这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。 令牌的使用A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。 此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。 1curl -H &quot;Authorization: Bearer ACCESS_TOKEN&quot; &quot;https://api.b.com&quot; 上面命令中，ACCESS_TOKEN就是拿到的令牌。 更新令牌令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。 具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。 B 网站验证通过以后，就会颁发新的令牌。 令牌与密码的区别1.令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。 2.令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。 3.令牌有权限范围，对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。","link":"/2021/04/28/OAuth%202.0/"},{"title":"Electron学习笔记","text":"Electron简介Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的 一个开源库。Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打 包为Mac，Windows和Linux系统下的应用来实现跨平台 Electron程序的基本结构一个基本的 Electron 程序需要包括下面几个文件： package.json：应用的入口文件，包含应用程序的相关配置信息: 作者，名称， 依赖项等，并指定程序的启动文件； main.js：应用的启动脚本，它将会在主进程中执行 index.html：应用程序的渲染页面。 主进程和渲染进程在 electron 中，最重要的一个概念就是主进程和渲染进程。Electron 运行 package.json 中指定的 main 脚本的进程被称为主进程。 在主进程中运行的脚本通过 创建web页面即渲染进程来展示用户界面。 一个 Electron应用总是有且只有一个主进程， 但是可以创建多个渲染进程。 在主线程中你可以使用Node.js，electron关于主线程操作的模块和一些公共模块。在 主线程中你需要创建和销毁app，创建和管理渲染进程，调用系统原生 API 等。 在主进程创建的一个个web页面各自运行着自己的进程，即渲染进程，渲染进程各自独 立，各自管理自己的页面，可以想象是浏览器一个个的 tab。在渲染线程中你可以使用 Node.js，DOM api，electron关于渲染线程操作的模块和一些公共模块。在渲染线程中你 需要使用js，html，css设计你的页面。 主进程使用 BrowserWindow 实例创建页面。 每个 BrowserWindow 实例都在自己 的渲染进程里运行页面。 当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被 终止。主进程管理所有的web页面和它们对应的渲染进程。 每个渲染进程都是独立的，它 只关心它所运行的 web 页面。如果有多个渲染进程，当其中一个窗口被关闭时，对应的窗 口对象引用要被释放掉。 主进程与渲染进程之间的通信一：使用ipcMain和ipcRenderer模块在主进程中使用ipcMain接收渲染线程发送过来的异步或同步消息，发送过来的消息将 触发事件。 在渲染进程中使用ipcRenderer向主进程发送同步或异步消息，也可以接收到主进程的 消息。 发送消息，事件名为 channel 回应同步消息, 你可以设置 event.returnValue 回应异步消息, 你可以使用 event.sender.send(…) 二：使用webcontents同样也可以从主进程向渲染进程发送消息，使用的是 webContents.send方法 (webContents负责渲染和控制网页, 是 BrowserWindow 对象的一个属性)。需要注意的是 往哪个窗口对应的渲染线程中发消息，就使用哪个窗口对象来调用。 三：使用remote在渲染进程中使用主进程模块 远程对象 remote 模块返回的每个对象（ 包括函数） 都代表了主进程中的一个对象（我们称之 为远程对象或者远程函数）。当调用远程对象的方法、执行远程函数或者使用远程构造器（ 函数） 创建新对象时，其实就是在发送同步的进程间消息。 在上面的例子中， BrowserWindow 和 win 都是远程对象，然而 new BrowserWindow 并没有在渲染进程中创建 BrowserWindow 对象。 而是在主进程中创建 了BrowserWindow 对象，并在渲染进程中返回了对应的远程对象，即 win 对象。只有可 枚举属性才能通过 remote 进行访问. //如果需要从主进程访问渲染进程，可以使用 webContents. executeJavascript 。 //注意事项： 因为安全原因，remote 模块能在窗口初始化设置中通过设 置 enableRemoteModule 选项为 false以此来禁用。 四:使用全局变量 渲染进程之间的通信 方案一 使用全局共享属性 方案二 利用主进程做消息中转 方案三 利用 remote 获取渲染进程发送消息 方案四 使用 ipcRenderer.sendTo() electron应用的打包electron-packager及electron-builder两种方式实现（Windows下） electron-packager：npm install electron-packager –save-dev electron-packager –platform= –arch= [optional flags…] elelctron-packager打包只是打包成各个平台下可执行文件，并不是安装包，如果需要打包 成安装包之类的可以使用electron-builder。 electron-builder：npm install electron-builder –save-dev 在package.json中增加配置 安装过程配置（nsis配置）： .exe是安装文件，默认安装在c盘。 .zip是压缩包，解压即用。 latest.yml 更新相关的信息","link":"/2021/11/30/electron%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"hooks","slug":"hooks","link":"/tags/hooks/"},{"name":"OAuth","slug":"OAuth","link":"/tags/OAuth/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"}],"categories":[{"name":"react","slug":"react","link":"/categories/react/"},{"name":"OAuth","slug":"OAuth","link":"/categories/OAuth/"},{"name":"Electron","slug":"Electron","link":"/categories/Electron/"}]}